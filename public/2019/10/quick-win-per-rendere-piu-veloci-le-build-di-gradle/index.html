<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=description content="Gradle ha ormai soppiantato Maven praticamente del tutto ed è diventato lo standard de facto per le build in tutto l’ecosistema Java e JVM-based: siccome i processi di build sono in assoluto uno dei miei argomenti preferiti, se non si fosse capito, ho passato una buona quantità di tempo a giocarci e ho scoperto un paio di trick interessanti che permettono di rendere più veloci le build.
Build più veloci = tempo di round-trip tra quando scrivete il codice e quando lo eseguite più rapido = vita migliore, vi ricordo, quindi qualunque investimento fatto per rendere più veloce anche solo di qualche secondo una cosa che fate dozzine di volte al giorno è assolutamente degno di esser fatto."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Quick win per rendere più veloci le build di Gradle"><meta name=twitter:description content="Gradle ha ormai soppiantato Maven praticamente del tutto ed è diventato lo standard de facto per le build in tutto l’ecosistema Java e JVM-based: siccome i processi di build sono in assoluto uno dei miei argomenti preferiti, se non si fosse capito, ho passato una buona quantità di tempo a giocarci e ho scoperto un paio di trick interessanti che permettono di rendere più veloci le build.
Build più veloci = tempo di round-trip tra quando scrivete il codice e quando lo eseguite più rapido = vita migliore, vi ricordo, quindi qualunque investimento fatto per rendere più veloce anche solo di qualche secondo una cosa che fate dozzine di volte al giorno è assolutamente degno di esser fatto."><meta property="og:title" content="Quick win per rendere più veloci le build di Gradle"><meta property="og:description" content="Gradle ha ormai soppiantato Maven praticamente del tutto ed è diventato lo standard de facto per le build in tutto l’ecosistema Java e JVM-based: siccome i processi di build sono in assoluto uno dei miei argomenti preferiti, se non si fosse capito, ho passato una buona quantità di tempo a giocarci e ho scoperto un paio di trick interessanti che permettono di rendere più veloci le build.
Build più veloci = tempo di round-trip tra quando scrivete il codice e quando lo eseguite più rapido = vita migliore, vi ricordo, quindi qualunque investimento fatto per rendere più veloce anche solo di qualche secondo una cosa che fate dozzine di volte al giorno è assolutamente degno di esser fatto."><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/2019/10/quick-win-per-rendere-piu-veloci-le-build-di-gradle/"><meta property="article:published_time" content="2019-10-29T09:02:06+00:00"><meta property="article:modified_time" content="2019-10-29T09:02:06+00:00"><base href=http://example.org/2019/10/quick-win-per-rendere-piu-veloci-le-build-di-gradle/><title>Quick win per rendere più veloci le build di Gradle · Raibaz.</title><link rel=canonical href=http://example.org/2019/10/quick-win-per-rendere-piu-veloci-le-build-di-gradle/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.13.0/css/all.css integrity=sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=/css/coder.min.31a395781f1caab4e90f89f7e5d0f0195b7c1944686a54267ed15c08a820827b.css integrity="sha256-MaOVeB8cqrTpD4n35dDwGVt8GURoalQmftFcCKgggns=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=http://example.org/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=http://example.org/images/favicon-16x16.png sizes=16x16><meta name=generator content="Hugo 0.74.1"></head><body class=colorscheme-light><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Raibaz.</a></section></nav><div class=content><section class="container page"><article><header><h1>Quick win per rendere più veloci le build di Gradle</h1></header><p>Gradle ha ormai soppiantato Maven praticamente del tutto ed è diventato lo standard <em>de facto</em> per le build in tutto l’ecosistema Java e JVM-based: siccome i processi di build sono in assoluto uno dei miei argomenti preferiti, se non si fosse capito, ho passato una buona quantità di tempo a giocarci e ho scoperto un paio di trick interessanti che permettono di rendere più veloci le build.</p><p>Build più veloci = tempo di round-trip tra quando scrivete il codice e quando lo eseguite più rapido = vita migliore, vi ricordo, quindi qualunque investimento fatto per rendere più veloce anche solo di qualche secondo una cosa che fate dozzine di volte al giorno è assolutamente degno di esser fatto.</p><p><strong>Caching degli artefatti</strong></p><p>Una build di Gradle, in realtà, è costituita da una serie di step e da una serie di moduli, ma è relativamente raro che sia necessario ribuildare veramente tutto: se il vostro progetto è composto da più sottoprogetti, al contrario, è facile che ne modifichiate uno per volta, e che non sia necessario ricompilare e rieseguire i test sugli altri.</p><p>Anche se questa cosa sembra assolutamente intuitiva, non è attiva di default su Gradle, ma va accesa esplicitamente aggiungendo a un file <code>gradle.properties</code> una riga che dica <code>org.gradle.caching=true</code>.</p><p>Così facendo, Gradle ricompilerà solo i moduli che vanno effettivamente ricompilati, prendendo dalla cache quelli che non sono stati modificati: soprattutto in ambiente locale, in cui ribuildate a ogni micromodifica, il vantaggio è evidente e consistente.</p><p><strong>Build in parallelo</strong></p><p>In questo caso, i benefici si notano maggiormente sui progetti composti da più moduli, ma di nuovo: per default, Gradle esegue le build in sequenza e in ordine alfabetico, a meno che un modulo non dipenda da un altro; nel mondo moderno, però, i computer hanno svariati core, ed è bene usarli tutti assieme, per cui, nello stesso <code>gradle.properties</code> di prima si può aggiungere una riga che dica <code>org.gradle.parallel=true</code> e BAM! per magia la compilazione, i test e quant’altro verranno eseguiti in parallelo, rendendo potenzialmente ancora più veloci le vostre build.</p><p>Occhio, però, a quel “potenzialmente”: il parallelismo è un grande potere, e da esso, come sapete, derivano grandi responsabilità, e non è detto che accenderlo risulti necessariamente in un vantaggio.</p><p>Innanzitutto, su macchine non carrozzatissime come quelle che spesso offrono i servizi di CI/CD as a service tipo quello di cui raccontavo <a href=https://www.raibaz.it/2019/09/ci-cd-as-a-service-con-codeship/>qui</a>, è possibile che cercare di eseguire più task contemporaneamente con risorse limitate generi solo un sacco di <em>context switching</em>, col risultato che le build finiscono per essere più lente quando eseguono cose in parallelo che quando lo fanno in sequenza, ma non è tutto.</p><p>Il parallelismo, infatti, è una di quelle cose in grado di introdurre i famigerati <em>heisenbug</em>, quei bug che si verificano solo randomicamente e sono praticamente impossibili da riprodurre in maniera deterministica, soprattutto se non siete stati attenti a gestire eventuali dipendenze tra i moduli del vostro progetto.</p><p>Se, per esempio, uno dei vostri moduli ha bisogno dell’output della build di un altro modulo ma non avete specificato che la sua build <code>dependsOn</code> l’altra, rischiate di trovarvi le build rotte randomicamente: per fortuna, Gradle sa di questa possibilità e mette a disposizione un tool molto bello per debuggare questi casi.</p><p>Lanciando la build col parametro <code>--scan</code>, infatti, Gradle creerà una fantastica pagina ricca di informazioni tipo queste:</p><p>Sì, ho chiaramente un problema con frontend:buildClientLocal.</p><p>Assolutamente indispensabile per capire quanto tempo richiede ciascun task, in che ordine vengono eseguiti e quali si possono parallelizzare.</p><p>Insomma, è vero che Gradle è ormai uno standard <em>de facto</em> e che le impostazioni di default sono più che valide per la maggioranza dei casi, ma è vero anche che ci sono alcuni quick wins che si possono mettere in pratica per ottenere vantaggi anche piuttosto sostanziosi.</p></article></section></div><footer class=footer><section class=container>©
2020
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main></body></html>