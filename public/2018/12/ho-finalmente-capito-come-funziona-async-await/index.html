<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=description content="Per lavoro ormai non scrivo più tanto codice, e quel poco che scrivo non è (fortunatamente, sfortunatamente, dipende dai gusti) Javascript, il linguaggio in più rapida evoluzione degli ultimi anni.
Sono stato senza scrivere Java per lunghi periodi, sono stato per lunghi e felicissimi periodi senza scrivere PHP e quando li ho ripresi in mano erano esattamente come li avevo lasciati, mentre Javascript è cambiato radicalmente pure nel corso degli anni in cui lo scrivevo tutti i giorni, figurarsi adesso che ho perso un po’ il contatto."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Ho finalmente capito come funziona async/await"><meta name=twitter:description content="Per lavoro ormai non scrivo più tanto codice, e quel poco che scrivo non è (fortunatamente, sfortunatamente, dipende dai gusti) Javascript, il linguaggio in più rapida evoluzione degli ultimi anni.
Sono stato senza scrivere Java per lunghi periodi, sono stato per lunghi e felicissimi periodi senza scrivere PHP e quando li ho ripresi in mano erano esattamente come li avevo lasciati, mentre Javascript è cambiato radicalmente pure nel corso degli anni in cui lo scrivevo tutti i giorni, figurarsi adesso che ho perso un po’ il contatto."><meta property="og:title" content="Ho finalmente capito come funziona async/await"><meta property="og:description" content="Per lavoro ormai non scrivo più tanto codice, e quel poco che scrivo non è (fortunatamente, sfortunatamente, dipende dai gusti) Javascript, il linguaggio in più rapida evoluzione degli ultimi anni.
Sono stato senza scrivere Java per lunghi periodi, sono stato per lunghi e felicissimi periodi senza scrivere PHP e quando li ho ripresi in mano erano esattamente come li avevo lasciati, mentre Javascript è cambiato radicalmente pure nel corso degli anni in cui lo scrivevo tutti i giorni, figurarsi adesso che ho perso un po’ il contatto."><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/2018/12/ho-finalmente-capito-come-funziona-async-await/"><meta property="article:published_time" content="2018-12-26T11:09:12+00:00"><meta property="article:modified_time" content="2018-12-26T11:09:12+00:00"><base href=http://example.org/2018/12/ho-finalmente-capito-come-funziona-async-await/><title>Ho finalmente capito come funziona async/await · Raibaz.</title><link rel=canonical href=http://example.org/2018/12/ho-finalmente-capito-come-funziona-async-await/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.13.0/css/all.css integrity=sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=/css/coder.min.31a395781f1caab4e90f89f7e5d0f0195b7c1944686a54267ed15c08a820827b.css integrity="sha256-MaOVeB8cqrTpD4n35dDwGVt8GURoalQmftFcCKgggns=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=http://example.org/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=http://example.org/images/favicon-16x16.png sizes=16x16><meta name=generator content="Hugo 0.74.1"></head><body class=colorscheme-light><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Raibaz.</a></section></nav><div class=content><section class="container page"><article><header><h1>Ho finalmente capito come funziona async/await</h1></header><p>Per lavoro ormai non scrivo più tanto codice, e quel poco che scrivo non è (fortunatamente, sfortunatamente, dipende dai gusti) Javascript, il linguaggio in più rapida evoluzione degli ultimi anni.</p><p>Sono stato senza scrivere Java per lunghi periodi, sono stato per lunghi e felicissimi periodi senza scrivere PHP e quando li ho ripresi in mano erano esattamente come li avevo lasciati, mentre Javascript è cambiato radicalmente pure nel corso degli anni in cui lo scrivevo tutti i giorni, figurarsi adesso che ho perso un po’ il contatto.</p><p>Cerco di tenermi aggiornato, ma scrivere il codice è, come tutti i lavori pratici, qualcosa con cui si perde la mano se non lo si fa tutti i giorni: caso ha voluto che avessi un progettino da fare nel (poco) tempo libero, però, e un po’ perché comunque so come funziona e un po’ per fare quello che in gergo si chiama “affilare l’ascia” ho deciso di farlo, per l’appunto, in Javascript.</p><p>Tra l’altro, è una cosa che deve fare diverse richieste HTTP in sequenza usando di volta in volta le risposte ricevute come parametri per le richieste successive, che è un po’ un grande classico delle applicazioni node e un pain point piuttosto famoso in Javascript.</p><p>All’inizio, come era inevitabile che fosse, l’ho scritto come lo sapevo scrivere, per cui sono finito ben presto nel più classico dei <a href=http://callbackhell.com/>callback hell</a> e, poco più tardi, nel più recente ma altrettanto classico <a href=https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513>promise hell</a>:</p><p>Ora ok, sicuramente il codice lì sopra è pienissimo di errori da n00b, ma maledetto tutto quanto quelle tre catch lì messe a freccia mi fanno salire il sangue al cervello e mi fanno venir voglia di piangere: non esiste al mondo che riesca a dormire la notte sapendo di aver scritto codice del genere.</p><p>Dato che si parla di affilare l’ascia, quindi, e che comunque il problema in questione sembra essere piuttosto comune, è stato relativamente semplice trovare una soluzione nei costrutti (ormai nemmeno troppo) nuovi del linguaggio, che nelle sue versioni più recenti ha aggiunto dello <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function>zucchero sintattico</a> volto appunto a risolvere questo tipo di problemi.</p><p>Il caso in questione, quindi, nel Javascript del 2018 quasi 2019, si scrive molto meglio così:</p><p>Meno righe, meno boilerplate, flusso più chiaro, codice più leggibile: la figata di async/await è che ti permette di distinguere tra codice asincrono e codice parallelo: callback e promises sono meccanismi più potenti, in un certo senso, perché permettono di scrivere codice che faccia più cose contemporaneamente (anche se, in un linguaggio single-threaded, il parallelismo è sempre illusorio), ma quando hai delle cose da fare in sequenza, seppure asincrona, è facile scrivere del codice agghiacciante come quello del mio primo esempio.</p><p>Usare async e await, invece, permette di scrivere del codice che fa cose sì asincrone, ma comunque in sequenza, aspettando di volta in volta che le operazioni asincrone finiscano.</p><p>Ok, è syntactic sugar e forse avrei potuto scrivere chiaro, conciso e leggibile anche usando correttamente le promises, ma chi me lo fa fare, se posso farlo molto più in fretta e semplicemente con un costrutto più recente? E soprattutto, se è un buon pretesto per imparare decentemente come funziona un costrutto recente che non avevo ancora avuto occasione di usare?</p></article></section></div><footer class=footer><section class=container>©
2020
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main></body></html>